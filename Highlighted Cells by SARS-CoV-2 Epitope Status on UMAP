#this code will do th trick except for the overay. The overlay uses a rought outluine of cluster 2(Naive) which is then made transparent and overlaid

library(dplyr)
library(stringdist)

# Define the pattern to compare with
pattern <- "CAGXNYGGSQGNLIF"

# Define function to calculate minimum Levenshtein distance from the pattern for each part of the cdr3 sequence
min_leven_distance <- function(cdr3, pattern) {
    junctions <- unlist(strsplit(cdr3, "\\."))  # Split cdr3 sequence at the period (.)
    distances <- sapply(junctions, function(j) stringdist(j, pattern, method = "lv"))
    return(min(distances))
}

# Add CDR3_tra and CDR3_trb columns based on splitting at '.'
RealBatchCorrectedBacherSeurat@meta.data <- RealBatchCorrectedBacherSeurat@meta.data %>%
    mutate(
        CDR3_tra = sapply(strsplit(cdr3, "\\."), `[`, 1),  # Extract part before the '.'
        CDR3_trb = sapply(strsplit(cdr3, "\\."), `[`, 2),  # Extract part after the '.'
        leven_meta = sapply(cdr3, min_leven_distance, pattern = pattern)  # Calculate min Levenshtein distance
    )

# Optionally, create a column to highlight cells based on Levenshtein distance threshold
# RealBatchCorrectedBacherSeurat@meta.data$highlight <- ifelse(RealBatchCorrectedBacherSeurat@meta.data$leven_meta <= 3, "highlight", "normal")
#--------
library(dplyr)

# Step 1: Collapse 'Epitope species' values for each unique 'CDR3', ensuring alphabetical order
df_collapsed <- aggregate(`Epitope species` ~ CDR3, data = df, FUN = function(x) paste(sort(unique(x)), collapse = ", "))

# Match and update 'epitopeSpecies' in the metadata based on either CDR3_tra or CDR3_trb
RealBatchCorrectedBacherSeurat@meta.data$epitopeSpecies <- ifelse(
    RealBatchCorrectedBacherSeurat@meta.data$CDR3_tra %in% df_collapsed$CDR3,
    df_collapsed$`Epitope species`[match(RealBatchCorrectedBacherSeurat@meta.data$CDR3_tra, df_collapsed$CDR3)],
    ifelse(
        RealBatchCorrectedBacherSeurat@meta.data$CDR3_trb %in% df_collapsed$CDR3,
        df_collapsed$`Epitope species`[match(RealBatchCorrectedBacherSeurat@meta.data$CDR3_trb, df_collapsed$CDR3)],
        NA  # If neither matches, set to NA
    )
)

# Add 'VDJmatch' column to metadata based on presence in VDJdb
RealBatchCorrectedBacherSeurat@meta.data <- RealBatchCorrectedBacherSeurat@meta.data %>%
    mutate(VDJmatch = ifelse(!is.na(epitopeSpecies), "Matched in VDJdb", "Not Matched in VDJdb"))

# Step 2: Collapse 'Epitope gene' values for each unique 'CDR3', ensuring alphabetical order
df_collapsed <- aggregate(`Epitope gene` ~ CDR3, data = df, FUN = function(x) paste(sort(unique(x)), collapse = ", "))

# Match and insert the sorted, collapsed 'Epitope gene' values based on either CDR3_tra or CDR3_trb
RealBatchCorrectedBacherSeurat@meta.data$`Epitope gene` <- ifelse(
    RealBatchCorrectedBacherSeurat@meta.data$CDR3_tra %in% df_collapsed$CDR3,
    df_collapsed$`Epitope gene`[match(RealBatchCorrectedBacherSeurat@meta.data$CDR3_tra, df_collapsed$CDR3)],
    ifelse(
        RealBatchCorrectedBacherSeurat@meta.data$CDR3_trb %in% df_collapsed$CDR3,
        df_collapsed$`Epitope gene`[match(RealBatchCorrectedBacherSeurat@meta.data$CDR3_trb, df_collapsed$CDR3)],
        NA  # If neither matches, set to NA
    )
)

# Add the 'spike' column based on 'Epitope gene' and 'VDJmatch' in the metadata
RealBatchCorrectedBacherSeurat@meta.data <- RealBatchCorrectedBacherSeurat@meta.data %>%
    mutate(spike = case_when(
        VDJmatch == "Not Matched in VDJdb" ~ "Not VDJdb Matched",  # If not matched in VDJdb
        !grepl("SARS-CoV-2", epitopeSpecies, ignore.case = TRUE) ~ "Non SARS-CoV-2 Matched",  # If matched in VDJdb but not SARS-CoV-2
        grepl("Spike", `Epitope gene`, ignore.case = TRUE) ~ "SARS-CoV-2 Spike Specific",  # If Epitope gene contains 'Spike'
        TRUE ~ "SARS-CoV-2 Other Specific"  # If Epitope gene does not contain 'Spike'
    ))

# View the updated metadata of RealBatchCorrectedBacherSeurat
head(RealBatchCorrectedBacherSeurat@meta.data)


# Load necessary libraries
library(dplyr)
library(ggplot2)
library(ggsignif)
library(Seurat) # Assuming you're using Seurat for DimPlot
# Define a function to create and save UMAP plots for specified categories
create_save_umap <- function(spike_category, plot_title, filename, sample_size = 500, seed = 314) {
# Step 1: Filter for the specified spike category
filtered_data <- RealBatchCorrectedBacherSeurat@meta.data %>%
filter(spike == spike_category)
# Step 2: Randomly sample cells from the filtered data
set.seed(seed) # Set seed for reproducibility
sampled_data <- filtered_data %>%
sample_n(sample_size)
# Step 3: Mark the sampled cells for highlighting
RealBatchCorrectedBacherSeurat@meta.data$highlight <- ifelse(
rownames(RealBatchCorrectedBacherSeurat@meta.data) %in% rownames(sampled_data), 
"highlight", 
"normal"
)
# Step 4: Extract UMAP coordinates
umap_data <- Embeddings(RealBatchCorrectedBacherSeurat, "umap") %>%
as.data.frame() %>%
rownames_to_column(var = "cell_id")
# Step 5: Merge UMAP coordinates with metadata
umap_data <- umap_data %>%
left_join(RealBatchCorrectedBacherSeurat@meta.data %>% rownames_to_column(var = "cell_id"), by = "cell_id")
# Step 6: Plot the UMAP with highlighting for the sampled cells
p <- ggplot() +
geom_point(
data = umap_data[umap_data$highlight == "normal", ], 
aes(x = umap_1, y = umap_2), 
color = "grey", 
alpha = 0.5
) +
geom_point(
data = umap_data[umap_data$highlight == "highlight", ], 
aes(x = umap_1, y = umap_2), 
color = "blue", 
size = 4
) +
labs(
title = paste0(plot_title, "\n"), 
x = "\nUMAP 1", 
y = "UMAP 2\n"
) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"), # Center and bold the title
axis.title.x = element_text(face = "bold"), # Bold x-axis title
axis.title.y = element_text(face = "bold") # Bold y-axis title
)
# Step 7: Save the plot as a square image with GRAPHFINAL dimensions
ggsave(
filename = filename, 
plot = p, 
width = 11, 
height = 11, 
units = "in", 
dpi = 300
)
# Optional: Print a message upon successful saving
message(paste("Plot saved as", filename))
}
# Define the categories, titles, and filenames
categories_info <- list(
list(
spike_category = "Non SARS-CoV-2 Matched",
plot_title = "Non SARS-CoV-2 Matched Cells",
filename = "UMAP_non_SARS-CoV-2_matched_graphfinal.png"
),
list(
spike_category = "Not VDJdb Matched",
plot_title = "Not VDJdb Matched Cells",
filename = "UMAP_not_VDJdb_matched_graphfinal.png"
),
list(
spike_category = "SARS-CoV-2 Other Specific",
plot_title = "SARS-CoV-2 Other Specific Cells",
filename = "UMAP_SARS-CoV-2_Other_Specific_graphfinal.png"
),
list(
spike_category = "SARS-CoV-2 Spike Specific",
plot_title = "SARS-CoV-2 Spike Specific Cells",
filename = "UMAP_SARS-CoV-2_Spike_Specific_graphfinal.png"
)
)
# Iterate over each category and create/save the plots
for (info in categories_info) {
create_save_umap(
spike_category = info$spike_category,
plot_title = info$plot_title,
filename = info$filename,
sample_size = 500, # Number of cells to sample
seed = 314 # Seed for reproducibility
)
}

